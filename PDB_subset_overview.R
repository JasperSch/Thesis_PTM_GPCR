#Jasper Schelfhout
#adapted from PDB_folder_overview
#Used to make overview table out of GO_counts table generated by PDB_subset_selection

#Extra needed data:
#CSV_file of GO terms in GO_counts with there meaning
#Phosphorylation data from DB_PTM
#Acetylatoin data from PLMD

#at the end of the file are lines to write output to excell file


library(readr)
library(rpart)
library(rpart.plot)
library(hash)
library(stringr)
library(vcd)
library(doBy)

#Enter FILE to translate it to dataset
DSf <- read_csv("~/School/2e_master_bioinformatica/Thesis/tables/PDB_files_overview_PDB_original_2018_11_05", 
               col_types = cols(`ENGINEERED_MUTATION` = col_logical(), 
                              RESOLUTION = col_double(),
                              GAP_AVERAGE = col_double(),
                              FUSIONCHAINS = col_logical(), 
                              MONOMERIC = col_logical(),
                              TRANSMEMBRANE = col_logical(), 
                              RESOLUTION_FINE= col_logical(),
                              HAS_PROTEIN_STRUCTURE = col_logical(),
                              COVERAGE_AVERAGE = col_double(),
                              COVERAGE_GOOD = col_logical()))
DSf$METHOD = as.factor(DS$METHOD)

GO_meaning <- read_csv("~/School/2e_master_bioinformatica/Thesis/Uniprot/Subset_ideas.txt")


PhosphorylationDS <- read_delim("~/School/2e_master_bioinformatica/Thesis/tables/Phosphorylation_dbPTM_20181122.txt", 
                                             "\t", escape_double = FALSE, col_names = FALSE, 
                                             trim_ws = TRUE)
Homo_sapiensDS<- read_delim("~/School/2e_master_bioinformatica/Thesis/tables/Homo_sapiens_PLMD_20181122.elm", 
                                         "\t", escape_double = FALSE, trim_ws = TRUE)
AcetylationDS <- subset(Homo_sapiensDS, Homo_sapiensDS$Type == 'Acetylation')



#Loop over GO_counts and make table with information: GO_overview
S_unique = vector()
S_overlapping = vector()
iii = 1
for (GO in GO_counts[,1]){
  DS <- subset(DSf, subset = ID %in% strsplit(GO_counts$PDBs[GO_counts$GO== GO], " ")[[1]])

  
  #Sorting gap numbers to match the divisions better
  ####################################################################################
  p = lapply(DS$PRESENT_AA, function(x) sort(as.integer(strsplit(x," ")[[1]])))
  r = lapply(DS$PRESENT_AA_RANGE, function(x) sort(as.integer(strsplit(x," ")[[1]])))
  g = list()
  for (i in 1:length(p)){
    if (length(p[[i]]) == length(r[[i]])){
      g[[i]] = p[[i]]/r[[i]]
    }
    else{
      print("check")
      g[[i]]=-1
    }
  }
  
  g_avg=array()
  for (i in 1:length(g)){
    g_avg[i] = sum(g[[i]])/ length(g[[i]])
  }
  
  
  DS$GAP_SORTED = g_avg
  
  
  
  
  #Make a subset of the table keeping only those that have passed first selection criteria
  ####################################################################################
  DS_SUB_GOOD = DS
  
  
  #Overlap checking for good structures
  ####################################################################################
  
  #STEP 1: Making a pairwise list of overlapping structures
  #-------------------------------------------------------
  
  #make dataframe of database identifiers + structure ID's
  DB_Identifiers = str_split_fixed(DS_SUB_GOOD$DB_IDENTIFIERS, " ", length(DS_SUB_GOOD$ID) )
  DB_Identifiers = as.data.frame(DB_Identifiers)
  
  #Check from which collumn empty collumns begin and remove all empty ones
  for (i in length(DB_Identifiers[,1]):1){
  colNumber = i
    if (paste(DB_Identifiers[,i], collapse = '') != "")
      break
  }                             
  
  DB_Identifiers = DB_Identifiers[1:colNumber]
  DB_Identifiers = cbind(DB_Identifiers, ID = DS_SUB_GOOD$ID)
  
  #Specialize dataframe to only include uniprot identifiers and count the amount of chains
  DB_Identifiers_UNP <- as.data.frame(lapply(DB_Identifiers, function(x) gsub("[0-9a-zA-Z_]+\\((?!UNP)[0-9a-zA-Z_]+\\)", "", x, perl=TRUE))) #removes al ID's except UNP ID's
  DB_Identifiers_UNP <- as.data.frame(lapply(DB_Identifiers_UNP, function(x) gsub("\\(UNP\\)", "", x, perl=TRUE)))
  DB_Identifiers_UNP <- data.frame(lapply(DB_Identifiers_UNP, as.character), stringsAsFactors=FALSE)
  DB_Identifiers_UNP$Entry_count <- apply(DB_Identifiers_UNP, 1, function(x) sum(x!= "")-1) #Minus 1 to not include the ID-cell. *****************BEWARE! DO NOT RUN THIS TWICE***********
  
  
  
  #Making the list with overlaps
  Overlaplist = data.frame(matrix(ncol = 3),stringsAsFactors = FALSE)
  

  
  #Searching every unique UNP identifier
  chains = DB_Identifiers_UNP[,1]
  for (i in 2:colNumber){
    chains = c(as.character(chains), as.character(DB_Identifiers_UNP[,i]))
  }
  print(length(chains))
  chains = unique(chains[chains !=""])
  print(length(chains))
  
  
  #For every unique UNP > search lines with UNP > extract structures > Compare structures and put in overlaplist
  for (chain in chains){
    print(toString(chain))
    
    #Find all unqiue structures in DB_Identifiers_UNP that have the chain
    matches = DB_Identifiers_UNP[grep(chain, DB_Identifiers_UNP[,1]),]
    for (i in 1:colNumber){
      matches = rbind(matches, DB_Identifiers_UNP[grep(chain, DB_Identifiers_UNP[,i+1]),])
    }
    matches = unique(matches)
  
    #If only 1 structure has the UNP, no need to start comparing structures
    if (length(matches$V1)==1){
    }
    else{
      #compare structures pairwaise and calculate overlap
      for (i in 1:(length(matches$V1)-1)){
        x = matches[i,]
        IDx = toString(x$ID)
        UNPx = x[1,1:colNumber]
        UNPx = UNPx[UNPx!=""]
        for (j in (i+1):length(matches$V1)){
          y = matches[j,]
          IDy = toString(y$ID)
          UNPy = y[1,1:colNumber]
          UNPy = UNPy[UNPy!=""]
          
          s1 = sum(is.element(UNPx,UNPy))
          s2 = sum(is.element(UNPy,UNPx))
          count = min(s1, s2) #This way 1 chain in 1 structure gets mapped to only 1 identical chain in the outher structure
          
          Totalchains = x$Entry_count + y$Entry_count
          overlap = count/Totalchains*2
          newrow = c(IDx, IDy, overlap)
          Overlaplist = rbind(Overlaplist, newrow)
        }
      }
    }
    
    #sort collumns alphabetically and remove redundant information
    x = paste(Overlaplist[,1], Overlaplist[,2], sep= " ")
    Overlaplist[,1] = as.vector(unlist(lapply(x, function(x){ str_sort(str_split(x, " ")[[1]])[1]})))
    Overlaplist[,2] = as.vector(unlist(lapply(x, function(x){ str_sort(str_split(x, " ")[[1]])[2]})))
    Overlaplist = unique(Overlaplist)
  }
  
  
  plot(Overlaplist[,3])

  
  #Step 3
  
  #Code has been cut here from original script since don't having any full overlaps in the datasets was causing errors
  
  Overlaplist_partialOverlap = Overlaplist
  plot(Overlaplist_partialOverlap[,3])
  Remaining_struct = unique(c(Overlaplist_partialOverlap[,1], Overlaplist_partialOverlap[,2]))
  
  
  #Putting unique and best of full overlapping structures and remaining partial overlapping structures together
  structures_unique = as.list(subset(DS_SUB_GOOD, select= ID, subset = !(ID %in% Overlaplist[,1] | ID %in% Overlaplist[,2])))
  structures_unique$ID
  
  
  S_overlapping[iii]= length(Remaining_struct)-1 #because NA gets included in this script
  S_unique[iii]   =  length(structures_unique[[1]])
  iii = iii+1
}

GO_overview = cbind(GO_counts, S_unique)
GO_overview = cbind(GO_overview, S_overlapping)
GO_overview = merge(GO_overview, GO_meaning)


#make dataframe of UNP database identifiers + structure ID's + acetylation counts + phosphorylation couts + boolean structure hasPTM
  pdbs_all = paste(paste(GO_counts$PDBs, ""), collapse = " ")
  pdbs_unique = unique(strsplit(pdbs_all, " ")[[1]])
  
  DSpdb = subset(DSf, subset = ID %in% pdbs_unique)
  
  DB_Identifiers = str_split_fixed(DSpdb$DB_IDENTIFIERS, " ", length(DSpdb$ID) )
  DB_Identifiers = as.data.frame(DB_Identifiers)
  #Check from which collumn empty collumns begin and remove all empty ones
  for (i in length(DB_Identifiers[,1]):1){
    colNumber = i
    if (paste(DB_Identifiers[,i], collapse = '') != "")
      break
  }                             
  DB_Identifiers = DB_Identifiers[1:colNumber]
  DB_Identifiers = cbind(DB_Identifiers, ID = DSpdb$ID)
  #Specialize dataframe to only include uniprot identifiers and count the amount of chains
  DB_Identifiers_UNP <- as.data.frame(lapply(DB_Identifiers, function(x) gsub("[0-9a-zA-Z_]+\\((?!UNP)[0-9a-zA-Z_]+\\)", "", x, perl=TRUE))) #removes al ID's except UNP ID's
  DB_Identifiers_UNP <- as.data.frame(lapply(DB_Identifiers_UNP, function(x) gsub("\\(UNP\\)", "", x, perl=TRUE)))
  DB_Identifiers_UNP <- data.frame(lapply(DB_Identifiers_UNP, as.character), stringsAsFactors=FALSE)
  
  i=1
  ac_count = vector()
  ph_count = vector()
  hasPTM = vector()
  for (i in 1:length(DB_Identifiers_UNP[,1])){
    id_unique =apply(DB_Identifiers_UNP[i,],1, function(x) unique(x))
    ac =lapply(id_unique[,1], function(x) sum(AcetylationDS$`Uniprot Accession` == x))
    ph =lapply(id_unique[,1], function(x) sum(PhosphorylationDS$X2 == x))
    ac_count[i] = sum(unlist(ac))
    ph_count[i] = sum(unlist(ph))
  }
  
  hasPTM= ac_count+ ph_count > 0
  DB_Identifiers_UNP = cbind(DB_Identifiers_UNP, ac_count)
  DB_Identifiers_UNP = cbind(DB_Identifiers_UNP, ph_count)
  DB_Identifiers_UNP = cbind(DB_Identifiers_UNP, hasPTM)
    
#Add to GO_overview PTM counting information
  StructuresWithPTM = vector()
  ac_count = vector()
  ph_count = vector()
  i=1
  for (pdblist in GO_overview$PDBs){
    x = strsplit(pdblist, " ")[[1]]
    ac = 0
    ph =0
    ptm =0
    for (pdb in x){
      ac = ac + DB_Identifiers_UNP$ac_count[DB_Identifiers_UNP$ID == pdb]
      ph = ph + DB_Identifiers_UNP$ph_count[DB_Identifiers_UNP$ID == pdb]
      ptm = ptm + DB_Identifiers_UNP$hasPTM[DB_Identifiers_UNP$ID == pdb]
    }
    StructuresWithPTM[i] = ptm
    ac_count[i] = ac
    ph_count[i] = ph
    i = i+1
  }

GO_overview = cbind(GO_overview, ac_count)
GO_overview = cbind(GO_overview, ph_count)
GO_overview = cbind(GO_overview, StructuresWithPTM)

#select GO term to get subset data frame with more information
for (process in GO_overview$process){
x = strsplit(GO_overview$PDBs[GO_overview$process == process], " ")[[1]]
DS_GO_of_interest = subset(DSf, subset = DSf$ID %in% x)
DS_GO_of_interest$HAS_PTM = lapply(DS_GO_of_interest$ID, function(x) DB_Identifiers_UNP$hasPTM[DB_Identifiers_UNP$ID == x])
DS_GO_of_interest = subset(DS_GO_of_interest, subset = HAS_PTM == TRUE)
AA_count  = unlist(lapply(DS_GO_of_interest$PRESENT_AA, function(x) sum(as.integer(strsplit(x," ")[[1]]))))
DS_GO_of_interest = cbind(DS_GO_of_interest, AA_count)
nam <- paste("DS_GO_", process, sep = "")
assign(nam, DS_GO_of_interest)
}
# library(xlsx)
 # write.xlsx(GO_overview, "c:/Users/Jasper/Documents/School/2e_master_bioinformatica/Thesis/GO_overviewV3.xlsx")



#extra code to get counts for specific sub part
x= c("1NR4",
     "107Z",
     "4UAI",
     "1XWD",
     "3UTQ",
     "4XSS",
     "5FO8",
     "2GTP",
     "4D0N",
     "2YIN",
     "1DS6",
     "4PO7",
     "5WRJ",
     "1M5N",
     "6F2U",
     "4IP8",
     "1KI1",
     "4XO7",
     "2ACX",
     "4L23",
     "4USO")
a = subset(DB_Identifiers_UNP, select = c("ID","ac_count", "ph_count"), subset = ID %in% x)
sum(a[,3])
